lc$log.change
mean(log.change[1:30)
mean(log.change[1:30])
log.change[1:30]
log.change[,1:30]
log.change[1:30]
lc$log.change[1:30]
#ECL298-026 In-class work session February 22, 2011#
#
#Data from email:#
k.emp=8#
states=2#
A=array(0,dim=c(k.emp,k.emp,states)) # demography matrices#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #transition matrix between states#
tf = 100 #number of time steps#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix #
#arguments:#
# growth.array: an array of stacked leslie matrices, nxnxm, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time)#create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(A)[1]) else N = initial.pop  #set up initial population#
 #
state = initial.state #define initial state#
for(i in 1:time) {#
  N = N / sum(N)#
  N = growth.array[,,state]%*%N#
  log.change[i] = log(sum(N))#
  states[i] = state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,])#
}#
#
running.mean[i] = mean(log.change[1:i])#
return(list(running.mean=running.mean, log.change=log.change,states=states))#
  #
}#
#
lc = estimate.l(A,tf,P)#
plot(1:tf, lc$running.mean, type="l")
lc$running.mean
#ECL298-026 In-class work session February 22, 2011#
#
#Data from email:#
k.emp=8#
states=2#
A=array(0,dim=c(k.emp,k.emp,states)) # demography matrices#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #transition matrix between states#
tf = 100 #number of time steps#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix #
#arguments:#
# growth.array: an array of stacked leslie matrices, nxnxm, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time)#create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(A)[1]) else N = initial.pop  #set up initial population#
 #
state = initial.state #define initial state#
for(i in 1:time) {#
  N = N / sum(N)#
  N = growth.array[,,state]%*%N#
  log.change[i] = log(sum(N))#
  states[i] = state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,])#
  running.mean[i] = mean(log.change[1:i])#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states))#
  #
}#
#
lc = estimate.l(A,tf,P)#
plot(1:tf, lc$running.mean, type="l")
#ECL298-026 In-class work session February 22, 2011#
#
#Data from email:#
k.emp=8#
states=2#
A=array(0,dim=c(k.emp,k.emp,states)) # demography matrices#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #transition matrix between states#
tf = 1000 #number of time steps#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix #
#arguments:#
# growth.array: an array of stacked leslie matrices, nxnxm, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time)#create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(A)[1]) else N = initial.pop  #set up initial population#
 #
state = initial.state #define initial state#
for(i in 1:time) {#
  N = N / sum(N)#
  N = growth.array[,,state]%*%N#
  log.change[i] = log(sum(N))#
  states[i] = state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,])#
  running.mean[i] = mean(log.change[1:i])#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states))#
  #
}#
#
lc = estimate.l(A,tf,P)#
plot(1:tf, lc$running.mean, type="l")
#ECL298-026 In-class work session February 22, 2011#
#
#Data from email:#
k.emp=8#
states=2#
A=array(0,dim=c(k.emp,k.emp,states)) # demography matrices#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #transition matrix between states#
tf = 10 #number of time steps#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix #
#arguments:#
# growth.array: an array of stacked leslie matrices, nxnxm, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time)#create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(A)[1]) else N = initial.pop  #set up initial population#
 #
state = initial.state #define initial state#
for(i in 1:time) {#
  N = N / sum(N)#
  N = growth.array[,,state]%*%N#
  log.change[i] = log(sum(N))#
  states[i] = state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,])#
  running.mean[i] = mean(log.change[1:i])#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states))#
  #
}#
#
lc = estimate.l(A,tf,P)#
plot(1:tf, lc$running.mean, type="l")
#ECL298-026 In-class work session February 22, 2011#
#Lottery Model#
#
#X[t,i] - frequency of species i at time t#
# n - nmber of species (start with 20)#
# d - fraction of sites are emptied at each time step#
# b[t, i] - birth rate of species i (per capita) at time t#
#
##X[t+1, i] = (1 - d*X[t,i]) + d*b[t+1,i]*X[t,i] / sum(b[t+1,]*X[t,])#
#
#inputs??#
#
n = 20 #number of species#
tf = 5000 # number of time steps#
b = seq(1:1.2,length=n) #set birth rates#
d = 0.1 #set fraction of sites that empty#
#
X = matrix(1/n, T, n) #set up data space with initial conditions#
#
#run simulation#
#
for(t in 1:(tf-1)) {#
  X[t+1,] = (1-d) * X[t,] + d*b*X[t,] / sum(b*X[t,])#
}
#ECL298-026 In-class work session February 22, 2011#
#Lottery Model#
#
#X[t,i] - frequency of species i at time t#
# n - nmber of species (start with 20)#
# d - fraction of sites are emptied at each time step#
# b[t, i] - birth rate of species i (per capita) at time t#
#
##X[t+1, i] = (1 - d*X[t,i]) + d*b[t+1,i]*X[t,i] / sum(b[t+1,]*X[t,])#
#
#inputs??#
#
n = 20 #number of species#
tf = 5000 # number of time steps#
b = seq(1:1.2,length=n) #set birth rates#
d = 0.1 #set fraction of sites that empty#
#
X = matrix(1/n, tf, n) #set up data space with initial conditions#
#
#run simulation#
#
for(t in 1:(tf-1)) {#
  X[t+1,] = (1-d) * X[t,] + d*b*X[t,] / sum(b*X[t,])#
}
#ECL298-026 In-class work session February 22, 2011#
#Lottery Model#
#
#X[t,i] - frequency of species i at time t#
# n - nmber of species (start with 20)#
# d - fraction of sites are emptied at each time step#
# b[t, i] - birth rate of species i (per capita) at time t#
#
##X[t+1, i] = (1 - d*X[t,i]) + d*b[t+1,i]*X[t,i] / sum(b[t+1,]*X[t,])#
#
#inputs??#
#
n = 20 #number of species#
tf = 5000 # number of time steps#
b = seq(1:1.2,length=n) #set birth rates#
d = 0.1 #set fraction of sites that empty#
#
X = matrix(1/n, tf, n) #set up data space with initial conditions#
#
#run simulation#
#
for(t in 1:(tf-1)) {#
  X[t+1,] = (1-d) * X[t,] + d*b*X[t,] / sum(b*X[t,])#
} #
#
matplot(X, type="l",lwd=3)
#ECL298-026 In-class work session February 22, 2011#
#Lottery Model#
#
#X[t,i] - frequency of species i at time t#
# n - nmber of species (start with 20)#
# d - fraction of sites are emptied at each time step#
# b[t, i] - birth rate of species i (per capita) at time t#
#
##X[t+1, i] = (1 - d*X[t,i]) + d*b[t+1,i]*X[t,i] / sum(b[t+1,]*X[t,])#
#
#inputs??#
#
n = 20 #number of species#
tf = 5000 # number of time steps#
b.mean = seq(1:1.2,length=n) #set birth rates#
b.var = 1#
Sgma=diag(n)#
d = 0.1 #set fraction of sites that empty#
#
X = matrix(1/n, tf, n) #set up data space with initial conditions#
#
#run simulation#
require(mnormt)#
for(t in 1:(tf-1)) {#
  b = exp(rmnorm(n=1,mean=b.mean,carcov=Sigma))#
  X[t+1,] = (1-d) * X[t,] + d*b*X[t,] / sum(b*X[t,])#
} #
#
matplot(X, type="l",lwd=3)
#ECL298-026 In-class work session February 22, 2011#
#Lottery Model#
#
#X[t,i] - frequency of species i at time t#
# n - nmber of species (start with 20)#
# d - fraction of sites are emptied at each time step#
# b[t, i] - birth rate of species i (per capita) at time t#
#
##X[t+1, i] = (1 - d*X[t,i]) + d*b[t+1,i]*X[t,i] / sum(b[t+1,]*X[t,])#
#
#inputs??#
#
n = 20 #number of species#
tf = 5000 # number of time steps#
b.mean = seq(1:1.2,length=n) #set birth rates#
b.var = 1#
Sgma=diag(n)#
d = 0.1 #set fraction of sites that empty#
#
X = matrix(1/n, tf, n) #set up data space with initial conditions#
#
#run simulation#
require(mnormt)#
for(t in 1:(tf-1)) {#
  b = exp(rmnorm(n=1,mean=b.mean,varcov=Sigma))#
  X[t+1,] = (1-d) * X[t,] + d*b*X[t,] / sum(b*X[t,])#
} #
#
matplot(X, type="l",lwd=3)
#ECL298-026 In-class work session February 22, 2011#
#Lottery Model#
#
#X[t,i] - frequency of species i at time t#
# n - nmber of species (start with 20)#
# d - fraction of sites are emptied at each time step#
# b[t, i] - birth rate of species i (per capita) at time t#
#
##X[t+1, i] = (1 - d*X[t,i]) + d*b[t+1,i]*X[t,i] / sum(b[t+1,]*X[t,])#
#
#inputs??#
#
n = 20 #number of species#
tf = 5000 # number of time steps#
b.mean = seq(1:1.2,length=n) #set birth rates#
b.var = 1#
Sigma=diag(n)#
d = 0.1 #set fraction of sites that empty#
#
X = matrix(1/n, tf, n) #set up data space with initial conditions#
#
#run simulation#
require(mnormt)#
for(t in 1:(tf-1)) {#
  b = exp(rmnorm(n=1,mean=b.mean,varcov=Sigma))#
  X[t+1,] = (1-d) * X[t,] + d*b*X[t,] / sum(b*X[t,])#
} #
#
matplot(X, type="l",lwd=3)
#ECL298-026 Homework: #
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population#
if(transition.matrix==1)  #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3])^2, dim(growth.array)[3], dim(growth.array)[3])#
else#
  P = transition.matrix#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)#
  N = growth.array[,,state]%*%N#
  log.change[i] = log(sum(N))#
  states[i] = state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,])#
  running.mean[i] = mean(log.change[1:i])#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states))#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 100 #number of time steps#
#
#
#Set up some empty #
#
l.out = estimate.l(A,tf,P)#
plot(1:tf, lc$running.mean, type="l")
#ECL298-026 Homework: #
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population#
if(transition.matrix==1)  #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3])^2, dim(growth.array)[3], dim(growth.array)[3])#
else#
  P = transition.matrix#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)#
  N = growth.array[,,state]%*%N#
  log.change[i] = log(sum(N))#
  states[i] = state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,])#
  running.mean[i] = mean(log.change[1:i])#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states))#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 100 #number of time steps#
#
#
#Set up some empty #
#
l.out = estimate.l(A,tf,P)#
plot(1:tf, l.out$running.mean, type="l")
#ECL298-026 Homework: #
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population#
if(transition.matrix==1)  #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3])^2, dim(growth.array)[3], dim(growth.array)[3])#
else#
  P = transition.matrix#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)#
  N = growth.array[,,state]%*%N#
  log.change[i] = log(sum(N))#
  states[i] = state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,])#
  running.mean[i] = mean(log.change[1:i])#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states))#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 150 #number of time steps#
#
#
#Set up some empty #
#
l.out = estimate.l(A,tf,P)#
plot(1:tf, l.out$running.mean, type="l")
#ECL298-026 Homework: #
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population#
if(transition.matrix==1)  #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3])^2, dim(growth.array)[3], dim(growth.array)[3])#
else#
  P = transition.matrix#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)#
  N = growth.array[,,state]%*%N#
  log.change[i] = log(sum(N))#
  states[i] = state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,])#
  running.mean[i] = mean(log.change[1:i])#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states))#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
l.out = estimate.l(A,tf,P)#
plot(1:tf, l.out$running.mean, type="l")
#ECL298-026 Homework: #
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3])^2, dim(growth.array)[3], dim(growth.array)[3])#
else#
  P = transition.matrix#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(running.mean)] #get the last point of the running mean#
plot(1:tf, model.out$running.mean, type="l")#
abline(h = l.est, col="red", lty=2,  )
growth.array
growth.array = A
P = matrix(1/(dim(growth.array)[3])^2, dim(growth.array)[3], dim(growth.array)[3])
P
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])
P
transition..matrix = 2
if(transition.matrix==1)  #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])#
else#
  P = transition.matrix
#ECL298-026 Homework: #
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(running.mean)] #get the last point of the running mean#
plot(1:tf, model.out$running.mean, type="l")#
abline(h = l.est, col="red", lty=2,  )
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(running.mean)] #get the last point of the running mean#
plot(1:tf, model.out$running.mean, type="l")#
abline(h = l.est, col="red", lty=2,  )
l.est
model.out
model.out$running.mean[length(running.mean)]
model.out$running.mean[length(model.out$running.mean)]
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
plot(1:tf, model.out$running.mean, type="l")#
abline(h = l.est, col="red", lty=2,  )
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l")#
plot(1:tf, model.out$running.mean, type="l")#
abline(h = l.est, col="red", lty=2,  )
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, l.est, paste("lambda = ", l.est, sep="")
)
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.24, paste("lambda = ", round(l.est,3) sep=""))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, paste("lambda = ", round(l.est,3), sep=""))
lot(-1:1,-1:1, type = "n", xlab = "Re", ylab = "Im")#
K <- 16; text(exp(1i * 2 * pi * (1:K) / K), col = 2)#
#
## The following two examples use latin1 characters: these may not#
## appear correctly (or be omitted entirely).#
plot(1:10, 1:10, main = "text(...) examples\n~~~~~~~~~~~~~~",#
     sub = "R is GNU ©, but not ® ...")#
mtext("«Latin-1 accented chars»: éè øØ å<Å æ<Æ", side=3)#
points(c(6,2), c(2,1), pch = 3, cex = 4, col = "red")#
text(6, 2, "the text is CENTERED around (x,y) = (6,2) by default",#
     cex = .8)#
text(2, 1, "or Left/Bottom - JUSTIFIED at (2,1) by 'adj = c(0,0)'",#
     adj = c(0,0))#
text(4, 9, expression(hat(beta) == (X^t * X)^{-1} * X^t * y))#
text(4, 8.4, "expression(hat(beta) == (X^t * X)^{-1} * X^t * y)",#
     cex = .75)#
text(4, 7, expression(bar(x) == sum(frac(x[i], n), i==1, n)))#
#
## Two more latin1 examples#
text(5,10.2,#
     "Le français, c'est façile: Règles, Liberté, Egalité, Fraternité...")#
text(5,9.8,#
     "Jetz no chli züritüütsch: (noch ein bißchen Zürcher deutsch)")
## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))#
## note that both of these use calls rather than expressions.#
###
text(1,10,  "Derivatives:", adj=0)#
text(1,9.6, expression(#
 "             first: {f * minute}(x) " == {f * minute}(x)), adj=0)#
text(1,9.0, expression(#
 "     second: {f * second}(x) "        == {f * second}(x)), adj=0)#
#
#
plot(1:10, 1:10)#
text(4, 9, expression(hat(beta) == (X^t * X)^{-1} * X^t * y))#
text(4, 8.4, "expression(hat(beta) == (X^t * X)^{-1} * X^t * y)",#
     cex = .8)#
text(4, 7, expression(bar(x) == sum(frac(x[i], n), i==1, n)))#
text(4, 6.4, "expression(bar(x) == sum(frac(x[i], n), i==1, n))",#
     cex = .8)#
text(8, 5, expression(paste(frac(1, sigma*sqrt(2*pi)), " ",#
                            plain(e)^{frac(-(x-mu)^2, 2*sigma^2)})),#
     cex = 1.2)#
#
## some other useful symbols#
plot.new(); plot.window(c(0,4), c(15,1))#
text(1, 1, "universal", adj=0); text(2.5, 1,  "\\042")#
text(3, 1, expression(symbol("\042")))#
text(1, 2, "existential", adj=0); text(2.5, 2,  "\\044")#
text(3, 2, expression(symbol("\044")))#
text(1, 3, "suchthat", adj=0); text(2.5, 3,  "\\047")#
text(3, 3, expression(symbol("\047")))#
text(1, 4, "therefore", adj=0); text(2.5, 4,  "\\134")#
text(3, 4, expression(symbol("\134")))#
text(1, 5, "perpendicular", adj=0); text(2.5, 5,  "\\136")#
text(3, 5, expression(symbol("\136")))#
text(1, 6, "circlemultiply", adj=0); text(2.5, 6,  "\\304")#
text(3, 6, expression(symbol("\304")))#
text(1, 7, "circleplus", adj=0); text(2.5, 7,  "\\305")#
text(3, 7, expression(symbol("\305")))#
text(1, 8, "emptyset", adj=0); text(2.5, 8,  "\\306")#
text(3, 8, expression(symbol("\306")))#
text(1, 9, "angle", adj=0); text(2.5, 9,  "\\320")#
text(3, 9, expression(symbol("\320")))#
text(1, 10, "leftangle", adj=0); text(2.5, 10,  "\\341")#
text(3, 10, expression(symbol("\341")))#
text(1, 11, "rightangle", adj=0); text(2.5, 11,  "\\361")#
text(3, 11, expression(symbol("\361")))
require(graphics)#
#
x <- seq(-4, 4, len = 101)#
y <- cbind(sin(x), cos(x))#
matplot(x, y, type = "l", xaxt = "n",#
        main = expression(paste(plain(sin) * phi, "  and  ",#
                                plain(cos) * phi)),#
        ylab = expression("sin" * phi, "cos" * phi), # only 1st is taken#
        xlab = expression(paste("Phase Angle ", phi)),#
        col.main = "blue")#
axis(1, at = c(-pi, -pi/2, 0, pi/2, pi),#
     labels = expression(-pi, -pi/2, 0, pi/2, pi))#
#
#
## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))#
## note that both of these use calls rather than expressions.#
###
text(1,10,  "Derivatives:", adj=0)#
text(1,9.6, expression(#
 "             first: {f * minute}(x) " == {f * minute}(x)), adj=0)#
text(1,9.0, expression(#
 "     second: {f * second}(x) "        == {f * second}(x)), adj=0)#
#
#
plot(1:10, 1:10)#
text(4, 9, expression(hat(beta) == (X^t * X)^{-1} * X^t * y))#
text(4, 8.4, "expression(hat(beta) == (X^t * X)^{-1} * X^t * y)",#
     cex = .8)#
text(4, 7, expression(bar(x) == sum(frac(x[i], n), i==1, n)))#
text(4, 6.4, "expression(bar(x) == sum(frac(x[i], n), i==1, n))",#
     cex = .8)#
text(8, 5, expression(paste(frac(1, sigma*sqrt(2*pi)), " ",#
                            plain(e)^{frac(-(x-mu)^2, 2*sigma^2)})),#
     cex = 1.2)
x <- seq(-4, 4, len = 101)#
y <- cbind(sin(x), cos(x))#
matplot(x, y, type = "l", xaxt = "n",#
        main = expression(paste(plain(sin) * phi, "  and  ",#
                                plain(cos) * phi)),#
        ylab = expression("sin" * phi, "cos" * phi), # only 1st is taken#
        xlab = expression(paste("Phase Angle ", phi)),#
        col.main = "blue")#
axis(1, at = c(-pi, -pi/2, 0, pi/2, pi),#
     labels = expression(-pi, -pi/2, 0, pi/2, pi))
## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
## some other useful symbols#
plot.new(); plot.window(c(0,4), c(15,1))#
text(1, 1, "universal", adj=0); text(2.5, 1,  "\\042")#
text(3, 1, expression(symbol("\042")))#
text(1, 2, "existential", adj=0); text(2.5, 2,  "\\044")#
text(3, 2, expression(symbol("\044")))#
text(1, 3, "suchthat", adj=0); text(2.5, 3,  "\\047")#
text(3, 3, expression(symbol("\047")))#
text(1, 4, "therefore", adj=0); text(2.5, 4,  "\\134")#
text(3, 4, expression(symbol("\134")))#
text(1, 5, "perpendicular", adj=0); text(2.5, 5,  "\\136")#
text(3, 5, expression(symbol("\136")))#
text(1, 6, "circlemultiply", adj=0); text(2.5, 6,  "\\304")#
text(3, 6, expression(symbol("\304")))#
text(1, 7, "circleplus", adj=0); text(2.5, 7,  "\\305")#
text(3, 7, expression(symbol("\305")))#
text(1, 8, "emptyset", adj=0); text(2.5, 8,  "\\306")#
text(3, 8, expression(symbol("\306")))#
text(1, 9, "angle", adj=0); text(2.5, 9,  "\\320")#
text(3, 9, expression(symbol("\320")))#
text(1, 10, "leftangle", adj=0); text(2.5, 10,  "\\341")#
text(3, 10, expression(symbol("\341")))#
text(1, 11, "rightangle", adj=0); text(2.5, 11,  "\\361")#
text(3, 11, expression(symbol("\361")))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, expression(log(lambda[A]) = l.est))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, expression(log(lambda[A]) == l.est))
## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))#
## note that both of these use calls rather than expressions.#
###
text(1,10,  "Derivatives:", adj=0)#
text(1,9.6, expression(#
 "             first: {f * minute}(x) " == {f * minute}(x)), adj=0)#
text(1,9.0, expression(#
 "     second: {f * second}(x) "        == {f * second}(x)), adj=0)
require(graphics)#
(s.e <- substitute(expression(a + b), list(a = 1)))  #> expression(1 + b)#
(s.s <- substitute( a + b,            list(a = 1)))  #> 1 + b#
c(mode(s.e), typeof(s.e)) #  "call", "language"#
c(mode(s.s), typeof(s.s)) #   (the same)#
# but:#
(e.s.e <- eval(s.e))          #>  expression(1 + b)#
c(mode(e.s.e), typeof(e.s.e)) #  "expression", "expression"#
#
substitute(x <- x + 1, list(x=1)) # nonsense#
#
myplot <- function(x, y)#
    plot(x, y, xlab=deparse(substitute(x)),#
         ylab=deparse(substitute(y)))
(s.e <- substitute(expression(a + b), list(a = 1)))  #> expression(1 + b)#
(s.s <- substitute( a + b,            list(a = 1)))  #> 1 + b#
c(mode(s.e), typeof(s.e)) #  "call", "language"#
c(mode(s.s), typeof(s.s)) #   (the same)#
# but:#
(e.s.e <- eval(s.e))          #>  expression(1 + b)#
c(mode(e.s.e), typeof(e.s.e)) #  "expression", "expression"#
#
substitute(x <- x + 1, list(x=1)) # nonsense#
#
myplot <- function(x, y)#
    plot(x, y, xlab=deparse(substitute(x)),#
         ylab=deparse(substitute(y)))
f1 <- function(x, y = x)             { x <- x + 1; y }#
s1 <- function(x, y = substitute(x)) { x <- x + 1; y }#
s2 <- function(x, y) { if(missing(y)) y <- substitute(x); x <- x + 1; y }#
a <- 10#
f1(a)# 11#
s1(a)# 11#
s2(a)# a#
typeof(s2(a))# "symbol"
myplot <- function(x, y)#
    plot(x, y, xlab=deparse(substitute(x)),#
         ylab=deparse(substitute(y)))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(expression(log(lambda[A]) == l.est))
)
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == l.est))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == l.est),list(l.est))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == l.est, list(l.est))
)
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == l.est, list(l.est = l.est))
)
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3)))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     bars#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(states,space=0)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(states,space=0,add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
     barplot(states,space=0)
     barplot(states)
states
     barplot(model.out$states)
     barplot(model.out$states-1)
     barplot(model.out$states-1,space=0)
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(model.out$states-1,space=0, col="#0000ff22",add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(model.out$states-1,space=0, col="red",add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(model.out$states-1,space=0, col="red", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(model.out$states-1,space=0, col="#0000ff22", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(c(model.out$states-1, -(model.out$states-1)), beside=FALSE#
             space=0, col="#0000ff22", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(c(model.out$states-1, -(model.out$states-1)), beside=FALSE,#
             space=0, col="#0000ff22", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(c((model.out$states-1)*2.5, -(model.out$states-1)), beside=FALSE,#
             space=0, col="#0000ff22", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(c((model.out$states-1)*2.4, -(model.out$states-1)), beside=FALSE,#
             space=0, col="#0000ff22", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(c((model.out$states-1)*2.4, -(model.out$states-1)),#
             space=0, col="#0000ff22", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(rbind((model.out$states-1)*2.4, -(model.out$states-1)),#
             space=0, col="#0000ff22", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
-(model.out$states-1)
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(rbind(-0.5*(model.out$states-1), 3*(model.out$states-1)),#
             space=0, col="#0000ff22", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(rbind(-0.5*(model.out$states-1), 2.95*(model.out$states-1)),#
             space=0, col="#0000ff22", border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(rbind(-0.5*(model.out$states-1), 2.95*(model.out$states-1)),#
             space=0, col=("#0000ff22","#0000ff22"), border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(rbind(-0.5*(model.out$states-1), 2.95*(model.out$states-1)),#
             space=0, col=c("#0000ff22","#0000ff22"), border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(rbind(-0.55*(model.out$states-1), 2.95*(model.out$states-1)),#
             space=0, col=c("#0000ff22","#0000ff22"), border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(rbind(-0.55*(model.out$states-1), 3.05*(model.out$states-1)),#
             space=0, col=c("#0000ff22","#0000ff22"), border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)),#
             space=0, col=c("#0000ff22","#0000ff22"), border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
     barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)),#
             space=0, col=c("white","#0000ff22"), border=NA, add=TRUE)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
#
     barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)),#
             space=0, col=c("blue","blue"), border=NA)#
             lines(1:tf, model.out$log.change, type="l", ylab="Log Change in Population", #
                  xlab ="Time", main="Population Changes")#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, ylab="Log Change in Population", #
        xlab ="Time", main="Population Changes") #
lines(1:tf, model.out$log.change)#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE) #
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes")#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x=250,y=1.5, c("State 1", "State 2"), fill=c("white", "#0000ff22"))#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"))#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 300 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 100 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 150 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(250, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 150 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.55*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(125, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 150 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.5*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(125, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 150 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.5*(model.out$states-1), 2.95*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(125, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.45*(model.out$states-1), 3*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(125, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.45*(model.out$states-1), 2.9*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(125, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
help(numeric)
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 10000 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.45*(model.out$states-1), 2.9*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(125, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 150 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.45*(model.out$states-1), 2.9*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(125, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 10000 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.45*(model.out$states-1), 2.9*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(125, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
#ECL298-026 Homework: #
#
rm(list=ls()) #clear workspace#
#
estimate.l = function(growth.array, time, transition.matrix, initial.state=1, initial.pop=1) {#
#A function to return the growth parameters from stochastic leslie matrix model#
#arguments:#
# growth.array: an array of stacked leslie matrices, n x n x m, where n is number of life stages and m number of states#
# transition.matrix: a leslie-style matrix of transition probabilities between states, default is equal probabilites for all transitions#
# initial.pop: an initial population distribution.  Default is ones for all life stages#
# initial.state:  the initial transition state.  Defauult is the first one#
# time: the number of time steps to run the model#
#
log.change = rep(0,time) #create empty data vector of log changes in abundance#
states = rep(0,time) #create an empty vector to store states#
running.mean = rep(0,time) #create empty vector of running mean#
if(initial.pop==1) N = rep(1, dim(growth.array)[1]) else N = initial.pop  #set up initial population distribution if none is defined#
if(transition.matrix==1)  { #set up an equal-probability transition matrix if one is not specified#
  P = matrix(1/(dim(growth.array)[3]), dim(growth.array)[3], dim(growth.array)[3])}#
else {#
  P = transition.matrix }#
state = initial.state #define initial state#
#
for(i in 1:time) {#
  N = N / sum(N)                  #normalize population distribution#
  N = growth.array[,,state]%*%N   #update population with current state leslie matrix#
  log.change[i] = log(sum(N))     #store log change in population#
  states[i] = state               #store system state#
  state = sample(1:dim(A)[3], size=1, prob=P[state,]) #update state based on probabilities in transition matrix#
  running.mean[i] = mean(log.change[1:i])  #store the running mean of the log change in population#
}#
#
return(list(running.mean=running.mean, log.change=log.change,states=states)) #create outputs in the form of a list#
  #
}#
#
#Parameters and Data#
k.emp=8 #define number of life stage#
states=2 #define number of system states#
A=array(0,dim=c(k.emp,k.emp,states)) # create an empty array to house the different demographic state Leslie matrices#
#
# El Nino "good" year (plot 2, 1982-83 in Horvitz and Schemske 1995, also used in Neubert and Caswell 2000, best year in best plot)#
# stages are: seed, seedling, juvenile, prerepro, small, med, large, xlarge adult plants#
A[,,1]=matrix(c(0.215,0.3407,0.0392,0,0,0,0,0,0,0.0088,0.115,0,0,0,0,0,2.8,0,0.3696,0.1739,0.1304,0.0217,0,0,8.9,0,0.025,0.4,0.325,0.05,0.05,0,12.7,0,0.0541,0.1351,0.4865,0.1081,0,0.027,20.3,0,0,0.1333,0.4667,0.0667,0.2667,0,32.8,0,0.1667,0,0,0.1667,0.5,0.1667,0,0,0,1,0,0,0,0),8) # matrices fill down column first#
# worst year/plot combination (plot 3, 1984-85)#
A[,,2]=matrix(c(0.55,0.0487,0.0021,0,0,0,0,0,0,0.0148,0.0148,0,0,0,0,0,0.9,0.05,0.1,0.05,0.05,0,0,0,5.3,0,0.1429,0.1429,0.2857,0,0,0,11.3,0,0.1111,0.2222,0.4444,0.1111,0,0,15.7,0,0.0417,0.2917,0.25,0.3333,0.0417,0,16.4,0,0,0.3636,0.3636,0.0909,0.1818,0,27.5,0,0,0.0909,0.4545,0.2727,0.0909,0.0909),8)#
#
P = rbind(c(0.7, 0.3), c(0.7, 0.3))  #Create a transition matrix for switching between states#
#
tf = 10000 #number of time steps#
#
#
#Set up some empty #
#
model.out = estimate.l(A,tf,P)  #run stochastic leslie matrix function #
l.est = model.out$running.mean[length(model.out$running.mean)] #get the last point of the running mean#
par(mfrow=c(1,2))#
plot(1:tf, model.out$log.change, ylab="Log Change in Population", #
     xlab ="Time", main="Population Changes", type="l")#
barplot(rbind(-0.45*(model.out$states-1), 2.9*(model.out$states-1)), space=0, #
        col=c("#0000ff22","#0000ff22"), border=NA, beside=FALSE, add=TRUE) #
legend(x="topright", c("State 1", "State 2"), fill=c("white", "#0000ff22"), bg="white")#
#
plot(1:tf, model.out$running.mean, type="l", ylab="Running Averge Log Change in Population",#
     xlab="Time", main="Running Average")#
abline(h = l.est, col="red", lty=2,  )#
text(8000, 0.25, substitute(log(lambda[A]) == a, list(a = round(l.est,3))))
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 10#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
}
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 10#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
}
modelout=stoch.ricker(R,a,tf,reps)
matplot(modelout)
modelout
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 10#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}
modelout=stoch.ricker(R,a,tf,reps)
matplot(modelout)
matplot(modelout, type="l")
modelout=stoch.ricker(R,a,tf,reps)
matplot(modelout, type="l")
dim(N)
dim(modelout)
hist(modelout[500,])
#ECL298-026 Class 8 Work Session - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#Part I - Case study of ricker model#
#N[t+1] = N[t]*R*exp(-a*N)#
#
#stochastic breakdown: #
#adults produce offspring at rate R - poisson distribution with mean R#
#assume each progeny survives with probability exp(-a*N) - also a poisson with #
# rate R*exp(-aN)#
#note sum of individual poissons is also poisson, so whole population is#
# poisson with rate N*Rexp(-a*N)#
#
#task 1: Try to simulate the model#
# parameters#
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 100#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}#
#
modelout=stoch.ricker(R,a,tf,reps)#
matplot(modelout, type="l")#
hist(modelout[500,])
#ECL298-026 Class 8 Work Session - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#Part I - Case study of ricker model#
#N[t+1] = N[t]*R*exp(-a*N)#
#
#stochastic breakdown: #
#adults produce offspring at rate R - poisson distribution with mean R#
#assume each progeny survives with probability exp(-a*N) - also a poisson with #
# rate R*exp(-aN)#
#note sum of individual poissons is also poisson, so whole population is#
# poisson with rate N*Rexp(-a*N)#
#
#task 1: Try to simulate the model#
# parameters#
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 1000#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}#
#
modelout=stoch.ricker(R,a,tf,reps)#
#matplot(modelout, type="l")#
hist(modelout[500,])
#ECL298-026 Class 8 Work Session - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#Part I - Case study of ricker model#
#N[t+1] = N[t]*R*exp(-a*N)#
#
#stochastic breakdown: #
#adults produce offspring at rate R - poisson distribution with mean R#
#assume each progeny survives with probability exp(-a*N) - also a poisson with #
# rate R*exp(-aN)#
#note sum of individual poissons is also poisson, so whole population is#
# poisson with rate N*Rexp(-a*N)#
#
#task 1: Try to simulate the model#
# parameters#
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 1000#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}#
#
modelout=stoch.ricker(R,a,tf,reps)#
#matplot(modelout, type="l")#
final = modelout[tf,])#
hist(final,30,freq=FALSE,col="red")
#ECL298-026 Class 8 Work Session - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#Part I - Case study of ricker model#
#N[t+1] = N[t]*R*exp(-a*N)#
#
#stochastic breakdown: #
#adults produce offspring at rate R - poisson distribution with mean R#
#assume each progeny survives with probability exp(-a*N) - also a poisson with #
# rate R*exp(-aN)#
#note sum of individual poissons is also poisson, so whole population is#
# poisson with rate N*Rexp(-a*N)#
#
#task 1: Try to simulate the model#
# parameters#
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 1000#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}#
#
modelout=stoch.ricker(R,a,tf,reps)#
#matplot(modelout, type="l")#
final = modelout([tf,])#
hist(final,30,freq=FALSE,col="red")
#ECL298-026 Class 8 Work Session - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#Part I - Case study of ricker model#
#N[t+1] = N[t]*R*exp(-a*N)#
#
#stochastic breakdown: #
#adults produce offspring at rate R - poisson distribution with mean R#
#assume each progeny survives with probability exp(-a*N) - also a poisson with #
# rate R*exp(-aN)#
#note sum of individual poissons is also poisson, so whole population is#
# poisson with rate N*Rexp(-a*N)#
#
#task 1: Try to simulate the model#
# parameters#
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 1000#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}#
#
modelout=stoch.ricker(R,a,tf,reps)#
#matplot(modelout, type="l")#
final = modelout[tf,]#
hist(final,30,freq=FALSE,col="red")
#ECL298-026 Class 8 Work Session - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#Part I - Case study of ricker model#
#N[t+1] = N[t]*R*exp(-a*N)#
#
#stochastic breakdown: #
#adults produce offspring at rate R - poisson distribution with mean R#
#assume each progeny survives with probability exp(-a*N) - also a poisson with #
# rate R*exp(-aN)#
#note sum of individual poissons is also poisson, so whole population is#
# poisson with rate N*Rexp(-a*N)#
#
#task 1: Try to simulate the model#
# parameters#
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 10000#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}#
#
modelout=stoch.ricker(R,a,tf,reps)#
#matplot(modelout, type="l")#
final = modelout[tf,]#
hist(final,30,freq=FALSE,col="red")
#ECL298-026 Class 8 Work Session - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#Part I - Case study of ricker model#
#N[t+1] = N[t]*R*exp(-a*N)#
#
#stochastic breakdown: #
#adults produce offspring at rate R - poisson distribution with mean R#
#assume each progeny survives with probability exp(-a*N) - also a poisson with #
# rate R*exp(-aN)#
#note sum of individual poissons is also poisson, so whole population is#
# poisson with rate N*Rexp(-a*N)#
#
#task 1: Try to simulate the model#
# parameters#
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 50000#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}#
#
modelout=stoch.ricker(R,a,tf,reps)#
#matplot(modelout, type="l")#
final = modelout[tf,]#
hist(final,30,freq=FALSE,col="red")
#ECL298-026 Class 8 Work Session - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#Part I - Case study of ricker model#
#N[t+1] = N[t]*R*exp(-a*N)#
#
#stochastic breakdown: #
#adults produce offspring at rate R - poisson distribution with mean R#
#assume each progeny survives with probability exp(-a*N) - also a poisson with #
# rate R*exp(-aN)#
#note sum of individual poissons is also poisson, so whole population is#
# poisson with rate N*Rexp(-a*N)#
#
#task 1: Try to simulate the model#
# parameters#
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 100#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}#
#
modelout=stoch.ricker(R,a,tf,reps)#
#matplot(modelout, type="l")#
final = modelout[tf,]#
hist(final,30,freq=FALSE,col="red")#
#
#task 2:
final
N.max = 100 #maximum number of individuals#
#define the P matrix#
P = matrix(0,N.max+1,N.max+1)#
for(i from 1:(N.max+1)) {#
  P[i,] = dpois(0:N.max,lambda=(i-1)*R*exp(-a*(i-1)))#
}#
#
#define pi (initial conditions)#
#
pi = matrix(0,1,N.max+1); pi[21] = 1 #set up pi with initial condition of 21
N.max = 100 #maximum number of individuals#
#define the P matrix#
P = matrix(0,N.max+1,N.max+1)#
for(i in 1:(N.max+1)) {#
  P[i,] = dpois(0:N.max,lambda=(i-1)*R*exp(-a*(i-1)))#
}#
#
#define pi (initial conditions)#
#
pi = matrix(0,1,N.max+1); pi[21] = 1 #set up pi with initial condition of 21
P
pi
image(P)
for(t in 1:(tf-1)) {#
  pi = pi%8%P#
}
for(t in 1:(tf-1)) {#
  pi = pi%*%P#
}
barplot(pi,col="red")
#run calculation#
for(t in 1:(tf-1)) {#
  pi = pi%*%P#
  barplot(pi,col="red")#
}
pi = matrix(0,1,N.max+1); pi[21] = 1 #set up pi with initial condition of 21
for(t in 1:(tf-1)) {#
  pi = pi%*%P#
  barplot(pi,col="red")#
  Sys.sleep(0.5)#
}
pi = matrix(0,1,N.max+1); pi[21] = 1 #set up pi with initial condition of 21
for(t in 1:(tf-1)) {#
  pi = pi%*%P#
  barplot(pi,col="red")#
  Sys.sleep(0.01)#
}
#
#
#parameters#
Rs = seq(1.1,15,length=50)#
N0 = 20#
K = 20#
as = log(Rs)/K#
N.max = 100#
#
P = matrix(0,N.max+1,N.max+1)#
probs = seq(0,length(Rs))#
#
for(j in 1:length(Rs)) {#
 #
  for(i in 1:(N.max+1)) {#
    P[i,] = dpois(0:N.max,lambda=(i-1)*Rs[j]*exp(-as[j]*(i-1)))#
  }#
  #
  pi = matrix(0,1,N.max+1); pi[N0] = 1#
  #
  for(t in 1:(tf-1)) {#
    pi = pi%*%P#
  }#
  probs[j] = pi[1]#
}
probs
plot(R,probs)
plot(Rs,probs)
#
#
#parameters#
Rs = seq(1.1,15,length=50)#
N0 = 20#
K = 20#
as = log(Rs)/K#
N.max = 100#
tf = 500#
#
P = matrix(0,N.max+1,N.max+1)#
probs = seq(0,length(Rs))#
#
for(j in 1:length(Rs)) {#
 #
  for(i in 1:(N.max+1)) {#
    P[i,] = dpois(0:N.max,lambda=(i-1)*Rs[j]*exp(-as[j]*(i-1)))#
  }#
  #
  pi = matrix(0,1,N.max+1); pi[N0] = 1#
  #
  for(t in 1:(tf-1)) {#
    pi = pi%*%P#
  }#
  probs[j] = pi[1]#
}#
#
plot(Rs,probs)
probs
Resilience
Rs
plot(Rs, probs)
length(Rs)
length(probs)
probs = seq(0,length(Rs))
probs
length(probs)
#
#
#parameters#
Rs = seq(1.1,15,length=50)#
N0 = 20#
K = 20#
as = log(Rs)/K#
N.max = 100#
tf = 500#
#
P = matrix(0,N.max+1,N.max+1)#
probs = rep(0,length(Rs))#
#
for(j in 1:length(Rs)) {#
 #
  for(i in 1:(N.max+1)) {#
    P[i,] = dpois(0:N.max,lambda=(i-1)*Rs[j]*exp(-as[j]*(i-1)))#
  }#
  #
  pi = matrix(0,1,N.max+1); pi[N0] = 1#
  #
  for(t in 1:(tf-1)) {#
    pi = pi%*%P#
  }#
  probs[j] = pi[1]#
}#
#
plot(Rs,probs)
#
#
#parameters#
Rs = seq(1.1,15,length=150)#
N0 = 20#
K = 20#
as = log(Rs)/K#
N.max = 100#
tf = 500#
#
P = matrix(0,N.max+1,N.max+1)#
probs = rep(0,length(Rs))#
#
for(j in 1:length(Rs)) {#
 #
  for(i in 1:(N.max+1)) {#
    P[i,] = dpois(0:N.max,lambda=(i-1)*Rs[j]*exp(-as[j]*(i-1)))#
  }#
  #
  pi = matrix(0,1,N.max+1); pi[N0] = 1#
  #
  for(t in 1:(tf-1)) {#
    pi = pi%*%P#
  }#
  probs[j] = pi[1]#
}#
#
plot(Rs,probs)
     main="Extinction Rates in Stochastic Ricker Model", type="b")
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500"#
     main="Extinction Rates in Stochastic Ricker Model", type="b")
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b")
#
#
#parameters#
Rs = seq(1.1,15,length=50)#
N0 = 20#
K = 20#
as = log(Rs)/K#
N.max = 100#
tf = 500#
#
P = matrix(0,N.max+1,N.max+1)#
probs = rep(0,length(Rs))#
#
for(j in 1:length(Rs)) {#
 #
  for(i in 1:(N.max+1)) {#
    P[i,] = dpois(0:N.max,lambda=(i-1)*Rs[j]*exp(-as[j]*(i-1)))#
  }#
  #
  pi = matrix(0,1,N.max+1); pi[N0] = 1#
  #
  for(t in 1:(tf-1)) {#
    pi = pi%*%P#
  }#
  probs[j] = pi[1]#
}#
#
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b")
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", col="red")
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", cex=0.5)
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", cex=0.5,#
     pch=21)
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", cex=0.5,#
     pch=19)
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", cex=0.5,#
     pch=19 col=c("red","green"))
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", cex=0.5,#
     pch=19, col=c("red","green"))
colors()
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", cex=0.5,#
     pch=21, bg="red")
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", cex=0.75,#
     pch=21, bg="red")
#ECL298-026 Class 9 Homework - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#task - plot the probability of extinction by time=500 as a function of R#
# Let R range from 1.1 to 15 with 50 increments#
# initial individuals = 20#
# a = log(R)/20#
# probability of extinct in pi[1] after 500 steps#
#
#parameters#
Rs = seq(1.1,15,length=50)#
N0 = 20#
K = 20#
as = log(Rs)/K#
N.max = 100#
tf = 500#
#
P = matrix(0,N.max+1,N.max+1)#
probs = rep(0,length(Rs))#
#
for(j in 1:length(Rs)) {#
 #
  for(i in 1:(N.max+1)) {#
    P[i,] = dpois(0:N.max,lambda=(i-1)*Rs[j]*exp(-as[j]*(i-1)))#
  }#
  #
  pi = matrix(0,1,N.max+1); pi[N0] = 1#
  #
  for(t in 1:(tf-1)) {#
    pi = pi%*%P#
  }#
  probs[j] = pi[1]#
}#
#
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", cex=0.75,#
     pch=21, bg="red")
#ECL298-026 Class 9 Homework - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#task - plot the probability of extinction by time=500 as a function of R#
# Let R range from 1.1 to 15 with 50 increments#
# initial individuals = 20#
# carrying capacity = 20#
# a = log(R)/carrying capacity#
# probability of extinction is pi[1] after 500 steps#
#
#parameters#
Rs = seq(1.1,15,length=50)#
N0 = 20#
K = 20#
as = log(Rs)/K#
N.max = 100#
tf = 500#
#
P = matrix(0,N.max+1,N.max+1)#
probs = rep(0,length(Rs))#
#
for(j in 1:length(Rs)) {#
 #
  for(i in 1:(N.max+1)) {#
    P[i,] = dpois(0:N.max,lambda=(i-1)*Rs[j]*exp(-as[j]*(i-1)))#
  }#
  #
  pi = matrix(0,1,N.max+1); pi[N0] = 1#
  #
  for(t in 1:(tf-1)) {#
    pi = pi%*%P#
  }#
  probs[j] = pi[1]#
}#
#
plot(Rs,probs,xlab="Growth Rate (R)",ylab="Probability of extinction at t=500",#
     main="Extinction Rates in Stochastic Ricker Model", type="b", cex=0.75,#
     pch=21, bg="red")
#ECL298-026 Class 8 Work Session - Demographic Stochasticity#
#Noam Ross, March 1, 2011#
#
#Part I - Case study of ricker model#
#N[t+1] = N[t]*R*exp(-a*N)#
#
#stochastic breakdown: #
#adults produce offspring at rate R - poisson distribution with mean R#
#assume each progeny survives with probability exp(-a*N) - also a poisson with #
# rate R*exp(-aN)#
#note sum of individual poissons is also poisson, so whole population is#
# poisson with rate N*Rexp(-a*N)#
#
#task 1: Try to simulate the model#
# parameters#
R = 1.5#
a = log(R)/20 #equilibrium is always 20#
tf = 500#
reps = 100#
stoch.ricker = function(R,a,tf, reps) {#
    N = matrix(20,tf,reps)#
    for(t in 1:(tf-1)) {#
      N[t+1,] = rpois(reps, lambda=R*N[t,]*exp(-a*N[t,]))#
    }#
    return(N)#
}#
#
modelout=stoch.ricker(R,a,tf,reps)#
#matplot(modelout, type="l")#
final = modelout[tf,]#
hist(final,30,freq=FALSE,col="red")#
#
#task 2: we have a Markov chain on a countable number of states#
# we will have to truncate the states to make them finite#
# states are integer population sizes#
# names states for indexing by adding 1#
# can write probability of going from state i to state j as matrix P[i,j]#
# pi[i] is probability of being at state i at time 0#
# what is probability of state i at time t?#
# the 'i'th entry of pi%*%P^t (note ^ means matrix exponent)#
#
N.max = 100 #maximum number of individuals#
#define the P matrix#
P = matrix(0,N.max+1,N.max+1)#
for(i in 1:(N.max+1)) {#
  P[i,] = dpois(0:N.max,lambda=(i-1)*R*exp(-a*(i-1)))#
}#
#
#define pi (initial conditions)#
#
pi = matrix(0,1,N.max+1); pi[21] = 1 #set up pi with initial condition of 21#
#
#run calculation#
for(t in 1:(tf-1)) {#
  pi = pi%*%P#
  barplot(pi,col="red")#
  Sys.sleep(0.01)#
}#
 #
#task - plot the probability of extinction by time=500 as a function of R#
# Let R range from 1.1 to 15 with 50 increments#
# initial individuals = 20#
# a = log(R)/20#
# probability of extinct in pi[1] after 500 steps
#EC298-026 Week 10 Class Session#
#Noam Ross#
#
#SIR Model#
tf = 100#
times = 1:tf #set of times for deterministic equations#
#
parms = list(  #create list of parameters#
#  b = # infection rate#
#  g = # recovery rate#
#  mu = #birth rate and death rate (in/out of susceptible class)#
  R0 = 8 #b/(mu+g)  #1/(u+g) is mean time of infection, so R0 is the mean number of infections#
  rho = 0.04 #mu/(mu+g)#
  a = 0.1 #g/(mu+g) #
  )#
#
events = rbind(  #this matrix defines what happens to each population class at a numbered event#
  c(1, -1, -1,  0,  0,  0)#
  c(0,  0,  1, -1, -1,  0)#
  c(0,  0,  0,  1,  0, -1)#
)#
#
N = 1000#
states0 = c( #a vector of initial state variables#
  S = 0.4*N # number susceptible#
  I = 0.01*N # number infected#
  R = N - S - I # number recovered#
  )#
    #
SIR.odes = function(times, states, parms) {#
#A set of ODEs for the SIR model, designed to be solved by lsoda()#
  #
  with(c(as.list(states), parms), { #extract parameters from 'parms' vector#
    N = S + I + R#
    dS = rho*(N - S) - R0 * S * I/N  #these are non-dimensionalized ODEs#
    dI = R0 * S * I/N - I#
    dR = a*I - rho*R#
#
  #dS = mu*(S + I + R) - mu*s - b*S*I/(S + I + R)  #dimensionalized versions#
  #dI = b*S*I/(S + I + R)#
  #dR = g*I - mu*R#
  #dN = 0#
  #
  return(list(c(dS, dI, dR)))#
  })#
}#
#
SIR.det = lsoda(states0, times, SIR.odes, parms)#
#
#stochastic sumulation#
#
vt[1] = 0#
counter = 1#
SIR.stoch = as.matrix(states0)#
while(vt[counter]<tf) {#
  rates = c(#
    birth = rho*N#
    death.S = rho*S#
    infection = R0*S*I/N#
    recovery = a*I#
    death.I = rho*I#
    death.R = rho*R#
  )#
  rate = sum(rates) #determine fundamental rate#
  weights = rates/rate #determine relative probability of events#
  dt = rexp(n=1,rate) #calculate time step#
  event = sample(1:6, size=1, prob=weights)  #select the event that occurs in this interval#
  #
  #updats#
  vt[counter+1] = vt[counter] + dt  #add time step#
  SIR.stoch = cbind(SIR.stoch, SIR.stoch[,counter]+events[,event]) #bind new SIR values to SIR matrix#
  counter=counter+1  #update counter#
}
parms = list(  #create list of parameters#
#  b = ,# infection rate#
#  g = ,# recovery rate#
#  mu = ,#birth rate and death rate (in/out of susceptible class)#
  R0 = 8, #b/(mu+g)  #1/(u+g) is mean time of infection, so R0 is the mean number of infections#
  rho = 0.04, #mu/(mu+g)#
  a = 0.1, #g/(mu+g) #
  )
parms = list(  #create list of parameters#
#  b = ,# infection rate#
#  g = ,# recovery rate#
#  mu = ,#birth rate and death rate (in/out of susceptible class)#
  R0 = 8, #b/(mu+g)  #1/(u+g) is mean time of infection, so R0 is the mean number of infections#
  rho = 0.04, #mu/(mu+g)#
  a = 0.1 #g/(mu+g) #
  )
events = rbind(  #this matrix defines what happens to each population class at a numbered event#
  c(1, -1, -1,  0,  0,  0)#
  c(0,  0,  1, -1, -1,  0)#
  c(0,  0,  0,  1,  0, -1)#
)
events = rbind(  #this matrix defines what happens to each population class at a numbered event#
  c(1, -1, -1,  0,  0,  0),#
  c(0,  0,  1, -1, -1,  0),#
  c(0,  0,  0,  1,  0, -1)#
)
N = 1000#
states0 = c( #a vector of initial state variables#
  S = 0.4*N, # number susceptible#
  I = 0.01*N, # number infected#
  R = N - S - I, # number recovered#
  )
states0 = c( #a vector of initial state variables#
  S = 0.4*N, # number susceptible#
  I = 0.01*N, # number infected#
  R = N - S - I # number recovered#
  )
N = 1000#
Si = 0.4*N # number susceptible#
Ii = 0.01*N # number infected#
Ri = N - S - I # number recovered#
states0 = c(S=Si, I=Ii, R=Ri) #a vector of initial state variables
N = 1000#
Si = 0.4*N # number susceptible#
Ii = 0.01*N # number infected#
Ri = N - Si - Ii # number recovered#
states0 = c(S=Si, I=Ii, R=Ri) #a vector of initial state variables
SIR.odes = function(times, states, parms) {#
#A set of ODEs for the SIR model, designed to be solved by lsoda()#
  #
  with(c(as.list(states), parms), { #extract parameters from 'parms' vector#
    N = S + I + R#
    dS = rho*(N - S) - R0 * S * I/N  #these are non-dimensionalized ODEs#
    dI = R0 * S * I/N - I#
    dR = a*I - rho*R#
#
  #dS = mu*(S + I + R) - mu*s - b*S*I/(S + I + R)  #dimensionalized versions#
  #dI = b*S*I/(S + I + R)#
  #dR = g*I - mu*R#
  #dN = 0#
  #
  return(list(c(dS, dI, dR)))#
  })#
}
SIR.det = lsoda(states0, times, SIR.odes, parms)
require(deSolve)
SIR.det = lsoda(states0, times, SIR.odes, parms)
SIR
SIR.det
plot(SIR.det[,1],SIR.det[,2],type="l")
vt[1] = 0#
counter = 1#
SIR.stoch = as.matrix(states0)#
while(vt[counter]<tf) {#
  rates = c(#
    birth = rho*N,#
    death.S = rho*S,#
    infection = R0*S*I/N,#
    recovery = a*I,#
    death.I = rho*I,#
    death.R = rho*R#
  )#
  rate = sum(rates) #determine fundamental rate#
  weights = rates/rate #determine relative probability of events#
  dt = rexp(n=1,rate) #calculate time step#
  event = sample(1:6, size=1, prob=weights)  #select the event that occurs in this interval#
  #
  #updats#
  vt[counter+1] = vt[counter] + dt  #add time step#
  SIR.stoch = cbind(SIR.stoch, SIR.stoch[,counter]+events[,event]) #bind new SIR values to SIR matrix#
  counter=counter+1  #update counter#
}
vt[1] = 0
vt = 0#
counter = 1#
SIR.stoch = as.matrix(states0)#
while(vt[counter]<tf) {#
  rates = c(#
    birth = rho*N,#
    death.S = rho*S,#
    infection = R0*S*I/N,#
    recovery = a*I,#
    death.I = rho*I,#
    death.R = rho*R#
  )#
  rate = sum(rates) #determine fundamental rate#
  weights = rates/rate #determine relative probability of events#
  dt = rexp(n=1,rate) #calculate time step#
  event = sample(1:6, size=1, prob=weights)  #select the event that occurs in this interval#
  #
  #updats#
  vt[counter+1] = vt[counter] + dt  #add time step#
  SIR.stoch = cbind(SIR.stoch, SIR.stoch[,counter]+events[,event]) #bind new SIR values to SIR matrix#
  counter=counter+1  #update counter#
}
vt = 0#
counter = 1#
SIR.stoch = as.matrix(states0)#
with(parms, {#
  while(vt[counter]<tf) {#
    rates = c(#
      birth = rho*N,#
      death.S = rho*S,#
      infection = R0*S*I/N,#
      recovery = a*I,#
      death.I = rho*I,#
      death.R = rho*R#
    )#
    rate = sum(rates) #determine fundamental rate#
    weights = rates/rate #determine relative probability of events#
    dt = rexp(n=1,rate) #calculate time step#
    event = sample(1:6, size=1, prob=weights)  #select the event that occurs in this interval#
  #
    #updats#
    vt[counter+1] = vt[counter] + dt  #add time step#
    SIR.stoch = cbind(SIR.stoch, SIR.stoch[,counter]+events[,event]) #bind new SIR values to SIR matrix#
    counter=counter+1  #update counter#
  }#
})
SIR
SIR.stoch
SIR["S"]
SIR
SIR.stoch["S"]
SIR.stoch[1]
SIR.stoch[S]
SIR.stoch["S"]
SIR
SIR.stoch
SIR.stoch["S",1]
vt = 0#
counter = 1#
SIR.stoch = as.matrix(states0)#
with(parms, {#
  while(vt[counter]<tf) {#
    with(list(S=SIR.stoch["S",counter],I=SIR.stoch.["I",counter],R=SIR.stoch["R",counter],N=sum(SIR.stoch[,counter]) {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
      })#
    rate = sum(rates) #determine fundamental rate#
    weights = rates/rate #determine relative probability of events#
    dt = rexp(n=1,rate) #calculate time step#
    event = sample(1:6, size=1, prob=weights)  #select the event that occurs in this interval#
  #
    #updats#
    vt[counter+1] = vt[counter] + dt  #add time step#
    SIR.stoch = cbind(SIR.stoch, SIR.stoch[,counter]+events[,event]) #bind new SIR values to SIR matrix#
    counter=counter+1  #update counter#
  }
with(parms, {#
  while(vt[counter]<tf) {#
    with(list(S=SIR.stoch["S",counter],I=SIR.stoch.["I",counter],R=SIR.stoch["R",counter],N=sum(SIR.stoch[,counter]) {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })#
    rate = sum(rates) #determine fundamental rate#
    weights = rates/rate #determine relative probability of events#
    dt = rexp(n=1,rate) #calculate time step#
    event = sample(1:6, size=1, prob=weights)  #select the event that occurs in this interval#
  #
    #updats#
    vt[counter+1] = vt[counter] + dt  #add time step#
    SIR.stoch = cbind(SIR.stoch, SIR.stoch[,counter]+events[,event]) #bind new SIR values to SIR matrix#
    counter=counter+1  #update counter#
  }#
})
with(parms, {#
  while(vt[counter]<tf) {#
    with(list(S=SIR.stoch["S",counter],I=SIR.stoch.["I",counter],R=SIR.stoch["R",counter],N=sum(SIR.stoch[,counter]), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })#
    rate = sum(rates) #determine fundamental rate#
    weights = rates/rate #determine relative probability of events#
    dt = rexp(n=1,rate) #calculate time step#
    event = sample(1:6, size=1, prob=weights)  #select the event that occurs in this interval#
  #
    #updats#
    vt[counter+1] = vt[counter] + dt  #add time step#
    SIR.stoch = cbind(SIR.stoch, SIR.stoch[,counter]+events[,event]) #bind new SIR values to SIR matrix#
    counter=counter+1  #update counter#
  }#
})
 with(list(S=SIR.stoch["S",counter], I=SIR.stoch.["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
    with(list(S=SIR.stoch["S",counter], I=SIR.stoch.["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
    rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )
parms
  while(vt[counter]<tf) {#
    with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch.["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter])), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })#
    rate = sum(rates) #determine fundamental rate#
    weights = rates/rate #determine relative probability of events#
    dt = rexp(n=1,rate) #calculate time step#
    event = sample(1:6, size=1, prob=weights)  #select the event that occurs in this interval#
  #
    #updates#
    vt[counter+1] = vt[counter] + dt  #add time step#
    SIR.stoch = cbind(SIR.stoch, SIR.stoch[,counter]+events[,event]) #bind new SIR values to SIR matrix#
    counter=counter+1  #update counter#
  }
    with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch.["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter])), {
    with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch.["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter])), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
list(S=SIR.stoch["S",counter], I=SIR.stoch.["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter])
with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch.["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]))), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
SIR.stoch
counter
counter = 1
with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch.["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]))), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
SIR.stoch = as.matrix(states0)
with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch.["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]))), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
   with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]))), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
rates
    with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]))), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      return(rates)#
      })
   with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]))), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
rates
   with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]))), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
rates
    with(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]))), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
        return(rates=rates)#
      })
rates
    within(c(parms, list(S=SIR.stoch["S",counter], I=SIR.stoch["I",counter], R=SIR.stoch["R",counter], N=sum(SIR.stoch[,counter]))), {#
      rates = c(#
        birth = rho*N,#
        death.S = rho*S,#
        infection = R0*S*I/N,#
        recovery = a*I,#
        death.I = rho*I,#
        death.R = rho*R#
        )#
      })
rates
# this R file is for simulating the simplest version of Hanski's incidence function model (IFM)#
# the models is continuous time markov chain where there are k patches with#
# A[i] is the area of patch i#
# D[i,j] is the distance between patch i and j#
# S[i] is the state of patch i with 0 being empty and 1 being occupied#
# patch i goes extinct at rate E[i]=alpha/A[i]^beta where alpha and beta are positive constants#
# patch i gets colonized at a rate C[i]=sum(a*S*exp(-b*D[,i])) where a and b are positive constants#
#
IFM=function(A,D,a,b,alpha,beta,T,S0,plot.it=TRUE,animate=TRUE){#
	k=length(A) # number of patches#
	time=0;#
	times=c(0); # vector to hold all the times#
	S=S0; # holds the current state vector#
	output=as.vector(S); # holds all of the state data#
	while(time<T){ # runs a loop until the total time T has elapsed#
		if(animate){  # if plots the landscape for each update whenever the animation is desired#
			par(fg="white",col.axis="white",mfrow=c(1,1)) #
			plot(x,y,cex=sqrt(A)/1.5,pch=21,bg=S+1,col=S+1)} # plots fillled in circles whose size is proportional to the radius; red means occupied and black unoccupied#
		E=alpha*S/A^beta # computes extinction rates for patches; E[i]=0 means patch is empty so no extinction#
		C=rowSums(a*exp(-b*D)%*%diag(S*A))*(1-S) # compute colonization rates for all the patches#
		next.update=rexp(1,rate=sum(E+C)) # determines the time to the next update#
		time=time+next.update # updates the total time elapsed#
		times=c(times,time) # add the new time to the times vector#
		which.patch=sample(1:k,size=1,prob=(E+C)/sum(E+C)) # determines which patch gets updated#
		S[which.patch]=(S[which.patch]+1)%%2 # empty an occupied patch, occupy an empty patch#
		output=rbind(output,S) # add the next row to the output data#
		if(sum(S)==0)time=T # end the simulation if all patches are empty #
		}#
	 if(plot.it){ # for the optional final plot, plots the time series and the final spatial configuration#
		par(mfrow=c(1,2))#
		par(fg="black",col.axis="black")#
	    plot(times,rowSums(as.matrix(output)),type="l",xlab="time",ylab="number occupied patches")#
		par(fg="white",col.axis="white")#
		plot(x,y,cex=sqrt(A)/1.5,pch=21,bg=S+1,col=S+1)#
		}#
	 return(as.matrix(cbind(times,output))) # returns a matrix whose first column is time and remaining columns are the time series for each patch#
	 }#
#
#
# testing out the function#
#
k=30 # patches#
width=10 # the width of the landscape #
x=rnorm(k)*width # randomly choosing centers for patches#
y=rnorm(k)*width#
r=runif(k)*4 # randomly choosing radii for patches#
alpha=1 # defining the main parameters#
beta=0.4#
a=0.005#
b=0.05#
xM=x%*%matrix(1,1,k) # the next three lines compute the distance matrix#
yM=y%*%matrix(1,1,k)#
D=sqrt((xM-t(xM))^2+(yM-t(yM))^2)#
A=pi*r^2 # areas of the patches#
S0=rep(1,k) # the initial state; all occupied#
T=100 # length of run#
load(file="IFM.rdata") #loading a nice version of the output from the last few lines#
test=IFM(A=A,D=D,a=a,b=b,alpha=alpha,beta=beta,S0=S0,T=T) # running the function
library(ctest)
ctest
library("ctest")
data(airquality)#
kruskal.test(Ozone ~ Month , data = airquality)
boxplot(Ozone ~ Month , data = airquality)
Sweave
Sweave(file="testing.tex")
